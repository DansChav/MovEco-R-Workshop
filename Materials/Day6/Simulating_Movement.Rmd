---
title: "Simulating_Movement"
author: "Eric Dougherty & Dana Seidel"
date: "December 5, 2017"
output:
  html_document:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Today we're going to build our own functions to simulate movement on landscape. This may be a slow process at first, but once you get the hang of building and using functions, you'll see how powerful they can be. Ultimately, we'll actually implement the functions we develop here on a landscape that we will also be simulating (later in the day). Throughout these exercises, I am going to use a code_folding option that will hide the code in the blocks below (at least in the HTML output) until you click on it to expand. I have chosen to do this because I will have a few challenges for you to try as we develop some of these functions. I don't want to give away all the answers in case you want to try to solve them independently, so they will be hidden until you choose to see them!

Let's begin by breaking down the movement process as we see it recorded by GPS or other telemetry devices. The two things we need to define a step are a step length and a turning angle. These are the two basic measures that we extract at the start of many analysis methods because these are the fundamental units of our analyses. We'll say, for now, that our starting point on a Euclidean plane is the origin (0,0) and the animal is able to move in any direction. Essentially, our problem is very simple: we want to choose a step length and turning angle and return the position of the individual when they are next recorded.

We can very easily use R's built-in capabilities of selecting a random number from a distribution to select a step length and turning angle for our next point. Our choice of distributions will be the most important factor here, but we are going to work from an extremely basic starting point and then move into some more complex (and more accurate) distributions. For our step lengths, lets select from a normal distribution (`base::rnorm`) whose mean is 500 meters and who has a standard deviation of 100 meters. If we wanted to see what a series of these random step lengths would look like, we could easily plot a histogram of, say, 10000 draws:

```{r}
hist(rnorm(n=10000, mean=500, sd=100))
```

Alright, it may not reflect and empirical movement path precisely, but it will do the job. Now lets use a uniform distribution to represent the turning angle. This angle can range from -pi to pi (-3.14 to 3.14), and if we take a look at 10000 draws from this uniform distribution, this is what it will look like:

```{r}
pi = 3.141593
hist(runif(n=10000, min=-pi, max=pi))
```

This suggests that our animal is completely unaffected by the previous direction it came from (i.e., its movements do not exhibit persistence in a given direction), so it is not entirely accurate, but it will do for now.

There are our two values, ready to be selected at random from our pre-defined distributions. But how do they turn into a new point? Well, trigonometry is how!

If we think back to high school, you'll perhaps recall that, with an angle and the length of the hypotenuse, we can solve for every other aspect of a right triangle. All movements can be reduced to right triangles, and what we really want are the lengths of the adjacent and opposite sides because those represent the changes in the x and y coordinates. All we need to simulate our own movement paths are these two coordinates.

So what does it look like to use trigonometry in R? Well, its quite straightforward. In order to extract the change in the y coordinate associated with a turning angle and step length, we want to solve for the opposite side. That means we should use sine with our known angle and our hypotenuse (opposite = sin(angle) * hypotenuse). To solve for the change in the x coordinate, we want to solve for the adjacent side, which requires the use of cosine with our known angle and the hypotenuse (adjacent = cos(angle) * hypotenuse).

That is pretty easy. Lets build a function now in which we begin with the starting point, which we will refer to as `xy`, the step length (`step`), and turning angle (`heading`), and then return a small data frame that records the new x and y coordinates as well as the inputs that brought us there.

```{r}
movement <- function(xy, step, heading) {
  
  #First we need to define pi
  pi = 3.141593
  
  #Then we split the starting point into an x_init and y_init
  x_init <- xy[1,1]
  y_init <- xy[1,2]
  
  #Here we translate the negative pi values into positive values
  #The headings now range from 0 to 2*pi
  if (heading < 0) {
    heading <- abs(heading) + pi
  }
  
  #Using this heading, and our sin function, we can solve for the change in y
  #Then we want to create a new value where we alter the starting y value
  y_change <- sin(heading)*step
  y_new <- y_init + y_change
  
  #The use cosine to determine the movement in x direction
  x_change <- cos(heading)*step
  x_new <- x_init + x_change

  #Finally, we create a data frame and save our new coordinates
  move.temp <- as.data.frame(matrix(0,1,4))
  move.temp[1,1] <- x_new
  move.temp[1,2] <- y_new
  move.temp[1,3] <- step
  move.temp[1,4] <- heading
  
  return(move.temp)
}
```

Now we have a nice little function. Let's see if it does what we want! Trial and error (or in coding parlance, debugging) represents a huge element of this process. Sometimes, we will debug within a function to make sure things are working at each step, but in this case, we have a pretty basic function, so we are going to try to run it over 100 points and see what happens. To do this, we are going to use a loop with a few parts. The first two parts are going to select the step length and turning angle from the distributions that we defined, then we are going to call the function, then we are going to add the output to one big data frame that will track all of the steps. This means that before the loop, we'll need to create this object, which we will call `steps.df`:

```{r}
steps.df <- data.frame(matrix(0,100,4))
colnames(steps.df) <- c("x", "y", "step.length", "turn.angle")

for (i in 2:100) {
  step <- rnorm(n=1, mean=500, sd=100)
  heading <- runif(n=1, min=-pi, max=pi)
  next.pt <- movement(steps.df[(i-1),1:2], step, heading)
  steps.df[i,] <- next.pt
}

head(steps.df)
plot(steps.df$x, steps.df$y, pch=19, type='b')
points(steps.df$x[1], steps.df$y[1], pch=19, col='red', cex=1.5)
```

Look at that! We've got ourselves an output. We can see that the movement tends to be pretty random in terms of the turning angles. Every once in a while, you may have a few consecutive points that lead the animal in one direction, but these are purely stochastic, and the animal doubles back on itself with approximately the same frequency.

Now if we run the same loop again, we will not get the same results because the entire process is stochastic. The step lengths and turning angles are chosen randomly, so no two paths will really look the same. If we felt that we may need to run this loop repeatedly, perhaps because we wanted to generate 20 paths of various lengths, we could place that into a function too!

```{r}
multi.move <- function(N, x) {
  all.paths <- list()
  
  for (j in 1:N) {
    steps.df <- data.frame(matrix(0,100,4))
    colnames(steps.df) <- c("x", "y", "step.length", "turn.angle")

    for (i in 2:x[j]) {
      step <- rnorm(n=1, mean=500, sd=100)
      heading <- runif(n=1, min=-pi, max=pi)
      next.pt <- movement(steps.df[(i-1),1:2], step, heading)
      steps.df[i,] <- next.pt
    }
    
    all.paths[[j]] <- steps.df
  }
  return(all.paths)
}
```

In `multi.move` we allow the user to input two parameters: `N` (the number of individual paths they want to generate) and `x` of vector of length N that sets the number of points in each of the paths. Now, we return a list of N different paths, and each can have the same or different lengths; it's all up to the user!

```{r}
multi.paths <- multi.move(3, c(100,110,120))
dim(multi.paths[[2]])
plot(multi.paths[[1]]$x, multi.paths[[1]]$y, pch=19, type='b', ylim=c(-6000,6000), xlim=c(-6000,6000))
points(multi.paths[[2]]$x, multi.paths[[2]]$y, pch=19, type='b', col='red')
points(multi.paths[[3]]$x, multi.paths[[3]]$y, pch=19, type='b', col='blue')
```

Now we can see that the second path in our new `multi.paths` object has 110 points because we told it to generate 110 points! How might you augment the `multi.move` function to allow the user to pass the starting coordinates of each individual to the function, rather than making all of them (0,0)? We can use the following points as our starting points:

```{r}
N = 3
start.pts <- data.frame(matrix(0,N,2))
colnames(start.pts) <- c("x", "y")
start.pts$x <- runif(n=N, min=-500, max=500)
start.pts$y <- runif(n=N, min=-500, max=500)
```

Now create a `multi.move2` function that uses them as the starting points of the three paths:

```{r}
multi.move2 <- function(N, x, start.pts) {
  all.paths <- list()
  
  for (j in 1:N) {
    steps.df <- data.frame(matrix(0,100,4))
    steps.df[1,1:2] <- start.pts[j,]
    colnames(steps.df) <- c("x", "y", "step.length", "turn.angle")

    for (i in 2:x[j]) {
      step <- rnorm(n=1, mean=500, sd=100)
      heading <- runif(n=1, min=-pi, max=pi)
      next.pt <- movement(steps.df[(i-1),1:2], step, heading)
      steps.df[i,] <- next.pt
    }
    
    all.paths[[j]] <- steps.df
  }
  return(all.paths)
}
```

Hopefully your attempt looked something like that! I think you can start to see the flexibility of functions. That is a pretty simple movement function with a few basic user inputs, but we may want to complicate things a bit more in order to make our function reflect real movement patterns more closely. We spent a lot of time talking about behavioral state analysis, so maybe we can implement some of these concepts in a new function.

This function is going to act similarly to the first, but instead of drawing all of the steps and angles randomly from the same normal or uniform distribution, we are going to have two separate distributions for the two different behavioral states, which we will think of as foraging and directional travel. We can get the parameters defining these distributions from the outputs of our HMM analysis. If you remember our two-state zebra model (`z`), we ended up with estimates that looked like this:

| Parameter | State 1 | State 2 |
| -------------------- | ---------- | ---------- |
| Mean Step Length (m) | 55.610 | 332.775 |
| SD Step Length (m) | 101.017 | 578.086 |


| Parameter | State 1 | State 2 | State 3 |
| ------------------------ | ---------- | ---------- |
| Mean Turning Angle (rad) | -0.096 | -0.030 |
| Mean Concentration | -0.254 | 19.656 |


This gives us a really good idea of how to parameterize steps and turning angles that more accurately reflect zebra movement, but we'll need to create some framework whereby we select which behavioral state the animal is in before we assign certain step lengths and turning angles. We also used the HMM we built to determine the probability of being in each of the three states (as well as more complex functions to determine the probability of transitioning between states). Lets try that now using our `multi.move` function as a starting point:

```{r}
library(CircStats)

multi.state <- function(N, x) {
  all.paths <- list()
  
  for (j in 1:N) {
    steps.df <- data.frame(matrix(0,100,5))
    colnames(steps.df) <- c("x", "y", "step.length", "turn.angle", "behav.state")

    for (i in 2:x[j]) {
      rand <- runif(1,0,1) #select the behavioral state for this step
      if (rand < 0.812) { #probability of state 1
        step <- rgamma(n=1, shape=((55.610^2)/(101.017^2)), rate=((55.610)/(101.017^2)))
        heading <- rvm(n=1, mean=-0.096, k=0.254)
        behave.state <- 1
      } else { #probability of state 2
        step <- rgamma(n=1, shape=((332.775^2)/(578.086^2)), rate=((332.775)/(578.086^2)))
        heading <- rvm(n=1, mean=-0.030, k=19.656)
        behave.state <- 2
      }
      
      next.pt <- movement(steps.df[(i-1),1:2], step, heading)
      steps.df[i,1:4] <- next.pt
      steps.df[i,5] <- behave.state
      
    }
    
    all.paths[[j]] <- steps.df
  }
  return(all.paths)
}
```

Let's run our new function and see how a path of 200 points looks:

```{r}
multi.states <- multi.state(1, c(200))
dim(multi.states[[1]])
plot(multi.states[[1]]$x, multi.states[[1]]$y, pch=19, type='b')
```

Now you'll notice that these paths cover a smaller area than when we used the normal distribution with a mean of 500 and an SD of 100 even though we transformed the values from kilometers to meters. We can take a look at what the gamma distributions of the steps from our different beahvioral states look like to illustrate the relative magnitude of the steps we're defining now:

```{r}
hist(rgamma(10000, shape=((55.610^2)/(101.017^2)), rate=((55.610)/(101.017^2))))
hist(rgamma(10000, shape=((332.775^2)/(578.086^2)), rate=((332.775)/(578.086^2))))
```

It is not especailly surprising that, even over twice as long of a path, our animal doesn't cover quite as much space. Our longest steps (which are the only ones that are at the same order of magnitude as our previous normal distribution) only occur about one-fifth of the time. The other ~80% of points are much smaller step sizes. But, but incorporating these behavioral states, we have simulated a much more realistic trajectory than what we had with our arbitrary distributions earlier.

Now, if you really want a challenge, we could redesign our `multi.state` function such that an initial behavioral state is assigned at the first step, and the animal transitions between states according to the functions we extracted during the HMM analysis. In order to do this, we are going to have to keep track of the time too, because these transition probability functions were based on a temporal covariate. You may remember that the zebra data were collected at a fix rate of 20 minutes, meaning that we will have sets of three points all with the same temporal covariate value (i.e., 3:00, 3:20, and 3:40 will all be given a value of 3). You should also note that the regression coefficient values given in the HMM output should be treated as values in a logistic regression, meaning that they should be used in the form: exp(intercept + (slope * Time)). Also, you'll probably want to use the `base::rbinom` command to determine whether the behavioral state will shift based on the resulting probabilities.

```{r}
multi.state2 <- function(N, x) {
  all.paths <- list()
  
  for (j in 1:N) {
    steps.df <- data.frame(matrix(0,100,5))
    colnames(steps.df) <- c("x", "y", "step.length", "turn.angle", "behav.state")
    
    rand <- runif(1,0,1)
    if (rand < 0.812) {
      prev.state <- 1
    } else {
      prev.state <- 2
    }
    steps.df[1,5] <- prev.state

    for (i in 2:x[j]) {
      time <- i %/% 3
      if (time > 23) {
        days <- i %/% 72
        time <- time - (24 * days)
      }
      
      if (prev.state == 1) {
        prob.1to2 <- exp(-2.564 + (-0.034 * time))
        if (prob.1to2 > 0 && prob.1to2 < 1) {
          trans.1to2 <- rbinom(1,1,prob.1to2)
        } else {
          trans.1to2 <- 0
        }
        if (trans.1to2 == 1) {
          behave.state <- 2
        } else {
          behave.state <- 1
        }
      } else {
        prob.2to1 <- exp(-1.544 + (0.016 * time))
        if (prob.2to1 > 0 && prob.2to1 < 1) {
          trans.2to1 <- rbinom(1,1,prob.2to1)
        } else {
          trans.2to1 <- 0
        }
        if (trans.2to1 == 1) {
          behave.state <- 1
        } else {
          behave.state <- 2
        }
      } 
      
      if (behave.state == 1) { #probability of state 1
        step <- rgamma(n=1, shape=((55.610^2)/(101.017^2)), rate=((55.610)/(101.017^2)))
        heading <- rvm(n=1, mean=-0.096, k=0.254)
      } else { #probability of state 2
        step <- rgamma(n=1, shape=((332.775^2)/(578.086^2)), rate=((332.775)/(578.086^2)))
        heading <- rvm(n=1, mean=-0.030, k=19.656)
      } 
      
      next.pt <- movement(steps.df[(i-1),1:2], step, heading)
      steps.df[i,1:4] <- next.pt
      steps.df[i,5] <- behave.state
      
      prev.state <- behave.state
    }
    
    all.paths[[j]] <- steps.df
  }
  return(all.paths)
}
```

This is a pretty serious challenge, and it should be noted that my way is not the only (nor necessarily the most efficient) way to create a working function. Before I pat myself on the back too much, lets make sure this works and then we'll go through the process that I coded up.

```{r}
multi.states2 <- multi.state2(1, c(200))
plot(multi.states2[[1]]$x, multi.states2[[1]]$y, pch=19, type='b')
```

Alright, it appears to do what we want it to do! So the first thing I did was come up with a way of calculating what time it was (assuming that the simulation began at hour 0) at the start of each step. The `%/%` operator is a helpful tool for dividing two values and eliminating the remainder (i.e., rounding down to the nearest whole value). Because the time in our HMM was only integer value ranging from 0 to 23, this was the best way to transform our 20 minute fixes into hourly values. The next complication was the fact that 200 points would result in values greater than 23, at which point we wanted the counter to reset to 0. I used a day counter which only kicked in after the time value went over 23, and it would calculate the number of days after that point and we could subtract 24*days from the time. 

The next challenge was to set the initial state for the individual, but this was pretty easy because we could just steal the same concept from above. We choose a random number between 0 and 1 and if that value falls within the proportion associated with a particular state, the animal was assigned to that `prev.state`. Now we start going through each of the time steps, and with each one, we want to evaluate whether the individual is going to remain in their present state or transition based on the equations we extracted using the HMM. This involves a few little workarounds because there are a few errors we may run into. The basic idea is to use the regression coefficients to obtain a probability, then use that probability to drive a random draw from a binomial distribution (which provides either a 0 or a 1). We may run into some issues though, because the `rbinom` command will only accept probabilities between 0 and 1 (which makes sense, but isnt necessarily the case for every hour one could input into the equations we obtain from the HMM). To circumvent these errors, we can use `if` statements that make the loop progress even if we may have otherwise hit an error. There are a few nested `if` statements here: 

- i) at the highest level, we use an `if` statement to check whether the prev.state of the individual is a 1 or 2; then, we calculate the transition probability from the prev.state to the other state at this particular time of day
- ii) next, we check `if` this probability falls between 0 and 1, and we run a binomial draw to see whether the individual actually transitions; `if` the probability for the transition is not between 0 and 1, we set the transition value to 0 and maintain the current state
- iii) finally, `if` the binomial draw results in a 1, the individual transitions into the appropriate state

Once all those checks are completed, we can finally assign the correct step length and turning angle given the current behavioral state. I also make one last change which results in another column that displays the current state for each step. 

```{r}
table(multi.states2[[1]]$behav.state)
```

Look at that! The result is a distribution of steps that aligns very nicely with the empirical track (i.e., approximately 80% of the points fall into behavioral state 1 and about 20% in behavioral state 2). This is a nice verification that our model is working as we intend.